# zsh起動ボトルネックパターン集

zshの起動が遅くなる主な原因とその影響度を分類します。

---

## 🔴 高影響（50ms以上）

### 1. `eval "$(brew shellenv)"`
**影響度:** 80-150ms

**原因:**
- brewコマンドの起動オーバーヘッド
- Ruby実装のため初回起動が重い
- 環境変数設定のための複雑な処理

**対策:**
→ `optimization-techniques.md` の「evalキャッシュ化」参照

---

### 2. `compinit`（キャッシュなし）
**影響度:** 60-200ms

**原因:**
- 全補完関数の読み込みとコンパイル
- 毎回実行すると非常に重い
- プラグインが多いほど悪化

**対策:**
→ `optimization-techniques.md` の「compinit最適化」参照

---

### 3. `eval "$(mise activate zsh)"` / `eval "$(asdf activate)"`
**影響度:** 50-100ms

**原因:**
- バージョン管理ツールの初期化
- shimの生成とPATH設定
- 複数言語対応のため処理が複雑

**対策:**
→ `optimization-techniques.md` の「mise/asdf最適化」参照

---

## 🟡 中影響（20-50ms）

### 4. `eval "$(starship init zsh)"`
**影響度:** 30-50ms

**原因:**
- プロンプト初期化処理
- Git状態取得のフック設定
- Rust製だが初期化は必要

**対策:**
→ `optimization-techniques.md` の「starship最適化」参照

---

### 5. `eval "$(direnv hook zsh)"`
**影響度:** 20-40ms

**原因:**
- ディレクトリ変更フックの設定
- 現在ディレクトリの`.envrc`チェック

**対策:**
→ `optimization-techniques.md` の「direnv最適化」参照

---

### 6. プラグインマネージャー（zinit, sheldon等）
**影響度:** 20-100ms（プラグイン数に依存）

**原因:**
- 複数プラグインの順次読み込み
- 依存関係の解決
- 初回コンパイル

**対策:**
→ `optimization-techniques.md` の「プラグイン遅延読み込み」参照

---

### 7. `eval "$(atuin init zsh)"`
**影響度:** 20-40ms

**原因:**
- 履歴同期の初期化
- SQLiteデータベース接続

**対策:**
- 遅延読み込み（初回コマンド実行時）

---

## 🟢 低影響（10-20ms）

### 8. 大量のエイリアス定義
**影響度:** 5-15ms

**原因:**
- source実行のオーバーヘッド
- パース処理

**対策:**
- 統合して1ファイルに
- 本当に使うものだけ残す

---

### 9. `source ~/.fzf.zsh`
**影響度:** 10-20ms

**原因:**
- キーバインド設定
- 補完関数の登録

**対策:**
- 必要な部分だけ抽出
- 条件付き読み込み

---

### 10. 複数の`if`文によるOS判定
**影響度:** 5-10ms

**原因:**
- 条件分岐のオーバーヘッド
- コマンド存在確認の繰り返し

**対策:**
- 判定結果をキャッシュ
- `case`文に統一

---

## 🔍 検出方法

### 静的解析で検出
- `eval`の使用箇所
- `compinit`の呼び出し
- サブシェル `$(...)` の使用

### 動的計測で検出
- `time zsh -i -c exit`
- `zprof`による関数別計測
- 個別コマンドの実行時間計測

---

## 📊 改善の目安

| 総起動時間 | 評価 | アクション |
|-----------|------|----------|
| < 100ms | 優秀 | 現状維持 |
| 100-200ms | 良好 | 軽微な改善で十分 |
| 200-500ms | 改善推奨 | 高影響項目を最適化 |
| > 500ms | 要改善 | 全面的な見直しが必要 |

---

## 🎯 優先順位の付け方

1. **計測値を取得**: `measure-individual.sh`で各処理の時間を測定
2. **影響の大きいものから対処**: 50ms以上 → 20ms以上 → それ以下
3. **効果を確認**: 最適化後に再度計測し、改善効果を検証
4. **バランスを考慮**: メンテナンス性を損なわない範囲で最適化

---

## 関連ドキュメント

- [optimization-techniques.md](./optimization-techniques.md) - 具体的な最適化手法
